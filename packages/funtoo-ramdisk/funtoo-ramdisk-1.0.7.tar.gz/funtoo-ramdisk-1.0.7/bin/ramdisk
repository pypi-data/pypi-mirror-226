#!/usr/bin/python3
import argparse
import asyncio
import os
import re
import subprocess
import sys
import tempfile

from rich.console import Console
from rich.highlighter import RegexHighlighter
from rich.theme import Theme

def parse_args():
	ap = argparse.ArgumentParser()
	for arg, kwargs in CLI_ARGS.items():
		if "positional" in kwargs and kwargs["positional"]:
			new_kwargs = kwargs.copy()
			del new_kwargs["positional"]
			ap.add_argument(arg, **new_kwargs)
		else:
			ap.add_argument("--" + arg, **kwargs)
	return ap.parse_args()


from_git = False

f_path = os.path.dirname(os.path.realpath(__file__))
proj_path = os.path.normpath(os.path.join(f_path, "../.git"))
if os.path.isdir(proj_path):
	base_path = os.path.normpath(os.path.join(proj_path, "../"))
	mod_path = os.path.join(base_path, "funtoo_ramdisk")
	support_path = os.path.join(mod_path, "support")
	if not os.path.exists(mod_path):
		raise FileNotFoundError(f"from_git: Did not find {mod_path} where I expected to find it.")
	if not os.path.exists(support_path):
		raise FileNotFoundError(f"from_git: Did not find {support_path} where I expected to find it.")
	from_git = True
	sys.path.insert(0, base_path)
	support_root = os.path.join(mod_path, "support")

if not from_git:
	# import the module just to use it to get the path to the files.
	import funtoo_ramdisk
	support_root = os.path.normpath(os.path.join(funtoo_ramdisk.__file__, "../support"))

from funtoo_ramdisk.initramfs import InitialRamDisk
from funtoo_ramdisk.config_files import ConfigFstab
from funtoo_ramdisk.version import __version__

if from_git:
	__version__ += "+git"

CLI_ARGS = {
	"kernel": {"default": None, "action": "store", "nargs": "?", "help": "What kernel to use to build initramfs (default: {fs_root}/usr/src/linux symlink.)"},
	"destination": {"default": None, "action": "store", "positional": True, "help": "The output initramfs filename to create."},
	"debug": {"default": False, "action": "store_true"},
	"compression": {"default": "xz", "action": "store", "help": "Compression method. One of: xz, zstd"},
	"backtrace": {"default": False, "action": "store_true", "help": "Show full backtrace of any exception."},
	"force": {"default": False, "action": "store_true", "help": "Force overwrite of initramfs destination if it exists."},
	"version": {"action": "version", "version": f"funtoo-ramdisk {__version__}"},
	"fs_root": {"default": "/", "action": "store", "help": "Root filesystem of modules to copy to initramfs, and look for kernel source."},
	"temp_root": {"default": "/var/tmp", "action": "store", "help": "Main directory to use for temporary directory creation."}
}

args = parse_args()


class FakeLogger:
	class MyHighlighter(RegexHighlighter):
		base_style = "ramdisk."
		highlights = [r"(?P<stats>^ ::.*)"]

	def __init__(self, debug=False):
		self.theme = Theme({"ramdisk.stats": "bold magenta"})
		self.console = Console(highlighter=None, theme=self.theme)
		self.debug_mode = debug

	def info(self, msg):
		self.console.print(" [turquoise2]::[default] " + msg)

	def warning(self, msg):
		self.console.print(" [orange1]::[default] " + msg)

	def error(self, msg):
		self.console.print(" [bright_white on dark_red]:collision::collision:[default] " + msg + " ")

	def done(self, msg):
		self.console.print(" [light_salmon1]:sparkle::sparkle:[default] " + msg)

	def debug(self, msg):
		if not self.debug_mode:
			return
		self.console.log(msg)

	def print_exception(self, show_locals=False):
		self.console.print_exception(show_locals=show_locals)


log = FakeLogger(debug=args.debug)

if args.debug:
	log.info("DEBUG enabled.")
if args.backtrace:
	from rich.traceback import install
	install(show_locals=True)


async def main_thread():
	log.warning(f"[turquoise2]funtoo-ramdisk [orange1]{__version__}[default] [grey63]:wolf:[default]")
	if from_git:
		log.info(f"Running from git repository [turquoise2]{os.path.dirname(proj_path)}[default]")
	output_initramfs = os.path.abspath(args.destination)
	if os.path.exists(output_initramfs) and not args.force:
		raise FileExistsError("Specified destination initramfs already exists -- use --force to overwrite.")
	fstab = ConfigFstab()
	root_entry = fstab.get_line_by_mount("/")
	if re.match("^/dev/sd.*", root_entry[0]):
		cmd = f"/sbin/blkid -s UUID -o value {root_entry[0]}"
		status, uuid = subprocess.getstatusoutput(cmd)
		if status != 0:
			raise ValueError(f"command: '{cmd}' failed with exit code {status}.")
		uuid = uuid.strip()
		if not uuid:
			raise ValueError(f"command: '{cmd}' was unable to give us a UUID.")
		log.warning(f"""Detected root device {root_entry[0]}, which could be a problem if you have more
than one ATA/SCSI disk. Since /dev/sd* device nodes are not consistently 
assigned, the initramfs could see this as a different device. Please do the the
following:

1. In /etc/fstab, change your root entry from:

   {'    '.join(root_entry)} 
   
   to:
   
   UUID={uuid}    {'    '.join(root_entry[1:])}

2. *Re-run* ego boot update so that GRUB will look for your root block device
    by UUID.

3. This problem should now be resolved, since now you are referring to the root
   block device using a UUID which will not change. Now, go ahead and try to
   create your ramdisk again.
	""")
	os.makedirs(os.path.dirname(output_initramfs), exist_ok=True)
	kernel_link = os.path.join(args.fs_root, "usr/src/linux")
	if args.kernel is None:
		log.info(f"No kernel specified, so going to try to use [turquoise2]{kernel_link}[default] symlink.")
		if not os.path.islink(kernel_link):
			raise FileNotFoundError(f"{kernel_link} does not exist or is not a symlink.")
		link_target = os.readlink(kernel_link)
		link_target = os.path.join(os.path.dirname(kernel_link), link_target)
		if not os.path.exists(link_target):
			raise FileNotFoundError(f"Could not find kernel from symlink {kernel_link} -- looking for {link_target} symlink target.")
		# grab data from Makefile, so we can determine correct kernel name for finding modules:
		datums = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]
		got_datums = {}
		with open(os.path.join(link_target, "Makefile"), "r") as mkf:
			while len(got_datums.keys()) != 4:
				line = mkf.readline()
				if not line:
					break
				for datum in datums:
					if datum not in got_datums:
						if line.startswith(f"{datum} ="):
							got_datums[datum] = line.split("=")[1].strip()
		if len(got_datums.keys()) != 4:
			raise ValueError(f"Could not extract: {datums} from {kernel_link}/Makefile.")
		kernel_version = "{VERSION}.{PATCHLEVEL}.{SUBLEVEL}{EXTRAVERSION}".format(**got_datums)
		status, current_version = subprocess.getstatusoutput("uname -r")
		current_version = current_version.strip()
		if kernel_version == current_version:
			log.info(f"Found: [orange1]{kernel_version}[default] (currently-active kernel)")
		else:
			log.info(f"Found: [orange1]{kernel_version}[default] (currently-active kernel is: [bright cyan]{current_version}[default]).")
		module_path = os.path.join(args.fs_root, f"lib/modules/{kernel_version}")
		if not os.path.exists(module_path):
			raise FileNotFoundError(f"Expected kernel module path {module_path} not found.")
	else:
		kernel_version = args.kernel
	with tempfile.TemporaryDirectory(prefix="ramdisk-", dir=args.temp_root) as temp_dir:
		ramdisk = InitialRamDisk(
			temp_root=temp_dir,
			support_root=support_root,
			kernel_version=kernel_version,
			compression=args.compression,
			modules_root=args.fs_root,
			logger = log
		)
		ramdisk.create_ramdisk(output_initramfs)

if __name__ == "__main__":
	success = True
	try:
		asyncio.run(main_thread())
	except Exception as e:
		log.error(f"{e.__class__.__name__}: {e}")
		if args.backtrace:
			log.print_exception(show_locals=False)
		success = False
	if not success:
		sys.exit(1)
