Metadata-Version: 2.1
Name: finoptim
Version: 0.0.21
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Dist: numpy
Requires-Dist: pandas
License-File: LICENSE
Summary: A small package to do some finoptim optimisations
Author-email: Timothée Obrecht <timothee@obrecht.xyz>
Requires-Python: >=3.10
Description-Content-Type: text/markdown; charset=UTF-8; variant=GFM
Project-URL: Homepage, https://github.com/tomtom-internal/sp-ccoe-finops-optimiser
Project-URL: Bug Tracker, https://github.com/tomtom-internal/sp-ccoe-finops-optimiser/issues

# FinOps package 

The best python package to help you optimise your cloud spendings



### Usage example


```python
import finoptim as fp
import pandas as pd


past_usage = pd.DataFrame(...)
guid_to_price = fp.cloud.load_aws_prices(as_dict=True)
prices = np.array(past_usqge.index.map(guid_to_price))

usage = fp.normalize(past_usage)

res = fp.optimise_past(usage, prices)
```


```python
predictions = pd.DataFrame(...) # some SQL query
current_reservations = pd.DataFrame(...) # some SQL query

normalize_reservations = fp.normalize(current_reservations)

res = fp.optimise_past(predictions, prices)
```

Now the res object hold the best levels of commitment on the time period.

```python
guid_to_instance_name = {"K7YHHNFGTNN2DP28" : 'i3.large', 'SAHHHV5TXVX4DCTS' : 'r5.large'}
res.format(instance_type=guid_to_instance_name)
print(res)
>>>
╭─────────────────┬──────────────────────────┬───────────────╮
│ instance_type   │  three_year_commitments  │ price_per_day │
├─────────────────┼──────────────────────────┼───────────────┤
│ i3.large        │           1338           │     2,886     │
│ r5.large        │           1570           │     2,564     │
│ savings plans   │           1937           │     1,937     │
╰─────────────────┴──────────────────────────┴───────────────╯
```


### TODO

- possibility to precise the period of the data in case it is not inferred correctly
- " call PyErr at suitable intervals inside your Rust function, and check the returned value. If it was -1, immediately return from your Rust function;"
- compute the better step size to avoid waiting too long
- coverage must folow the same inputs as cost
- allow for long DataFrame as input
- the cost function should return a gradient when evaluated (save some compute)

- add in documentation that for now optimisation only works if you have RI < SP < OD
