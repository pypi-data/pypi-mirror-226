from __future__ import annotations

import typing
from abc import abstractmethod
from collections.abc import Set
from copy import copy as copy_func
from typing import Protocol, Iterable, Sized, Collection, Literal, Mapping, TypeVar, ClassVar

import pandas as pd

from mdata.core.header import ObservationSpec, Meta, Header
from mdata.core.shared_defs import TimeseriesFeatureLabel, TimeseriesFeatureLabels, ObservationTypeValue, \
    ObservationType, ObservationSpecLabel, ObservationSpecIdentifier, EventSpecLabel, MeasurementSpecLabel, Extension
from mdata.core.util import SlimMapping, intersection, symmetric_difference, Copyable

P = typing.ParamSpec('P')


@typing.runtime_checkable
class ObservationTypeSpecific(Protocol):
    # observation_type: ClassVar[ObservationType]
    @property
    @abstractmethod
    def observation_type(self) -> ObservationType: ...


@typing.runtime_checkable
class EventSpecific(Protocol):
    E = ObservationType.E
    observation_type: ClassVar[ObservationType] = E


@typing.runtime_checkable
class MeasurementSpecific(Protocol):
    M = ObservationType.M
    observation_type: ClassVar[ObservationType] = M


@typing.runtime_checkable
class TimeseriesSpecProtocol(ObservationTypeSpecific, Iterable[str], Sized, Copyable, Protocol):
    """
    Immutable object containing information derived from an observation spec.
    Used to store auxiliary structural metadata related to a dataframe.
    Implementations are specific to an observation type.
    """

    @classmethod
    def of(cls, label: ObservationSpecLabel, base_spec: ObservationSpec) -> typing.Self:
        """Create a new instance from a label and base `ObservationSpec`."""
        ...

    @property
    @abstractmethod
    def identifier(self) -> ObservationSpecIdentifier:
        """The identifier, i.e., `(type, label)` tuple of this spec."""
        ...

    @property
    @abstractmethod
    def label(self) -> ObservationSpecLabel:
        """The label of this observation spec."""
        ...

    @property
    @abstractmethod
    def base(self) -> ObservationSpec:
        """The underlying `ObservationSpec` as defined a Machine Data header."""
        ...

    @property
    @abstractmethod
    def features(self) -> TimeseriesFeatureLabels:
        """The names of the features of this spec."""
        ...

    @property
    @abstractmethod
    def feature_count(self) -> int:
        """The number of features in this spec."""
        ...

    @property
    @abstractmethod
    def long_names(self) -> TimeseriesFeatureLabels:
        """
        The long names of the features. Intended to be more human-readable.
        Equal to the basic feature names if not explicitly specified in the metadata of a Machine Data header.
        """
        ...

    @abstractmethod
    def feature_intersection(self, other: TimeseriesSpecProtocol) -> list[str]:
        """Returns the features defined in both `self` and `other`."""
        ...

    @abstractmethod
    def feature_symmetric_difference(self, other: TimeseriesSpecProtocol) -> tuple[list[str], list[str]]:
        """Returns a tuple of features defined in one but not the other spec."""
        ...

    @abstractmethod
    def project(self, feature_selection: bool | str | Collection[str]) -> typing.Self:
        """
        Project the spec to a subset of its features.

        :param feature_selection: if boolean, the selection is True/False = all/no features, if str, a singular feature
        """
        ...

    @abstractmethod
    def is_mergeable(self, other: TimeseriesSpecProtocol) -> bool:
        """Decides whether `self` and `other` are mergeable, i.e., whether both spec identifiers are equal."""
        ...

    @abstractmethod
    def merge(self, other: typing.Self) -> typing.Self:
        """
        Merge `self` and `other` by appending the feature definitions of `other` that are not already in `self`.
        A new instance is created.

        :raises: TimeseriesSpecMergeException
        """
        ...


TSSpec = TypeVar('TSSpec', bound=TimeseriesSpecProtocol)


class TimeseriesViewProtocol(ObservationTypeSpecific, Protocol[TSSpec]):
    """
    An immutable representation of a view on a collection of observations through a specific timeseries spec.
    Typically generated by `TimeseriesContainerProtocol` implementations and not end-users.
    """

    @property
    @abstractmethod
    def timeseries_spec(self) -> TSSpec:
        """
        The timeseries spec describing the contained observations' features, i.e., columns in `self.df`.

        :rtype: an implementation of `TimeseriesSpecProtocol`
        """
        ...

    @property
    @abstractmethod
    def df(self) -> pd.DataFrame:
        """The actual dataframe holding the observation data."""
        ...

    @classmethod
    @abstractmethod
    def of(cls, timeseries_spec: TSSpec, df: pd.DataFrame, *args: P.args, **kwargs: P.kwargs) -> typing.Self:
        """Create a new encapsulated view on the given dataframe with the specified spec."""
        ...

    @property
    @abstractmethod
    def objects(self) -> Set[str]:
        """The set of object identifiers occurring in `self.df`."""
        ...

    @property
    @abstractmethod
    def observation_count(self) -> int:
        """The number of contained observations. Equivalently, length of `self.df`."""
        ...

    @abstractmethod
    def feature_column_view(self, include_time_col=True, include_object_col=False, add_spec_id_prefix=False,
                            use_long_names=False) -> pd.DataFrame:
        """
        Generate a view on the underlying dataframe.

        :param include_time_col: whether to include the `MDConcepts.Time` column
        :param include_object_col: whether to include the `MDConcepts.Object` column
        :param add_spec_id_prefix: whether to prefix the column names with the spec id (useful for avoiding name collisions when joining dataframes)
        :param use_long_names: whether to rename the columns to use the "long" feature names specified in `self.timeseries_spec`
        """
        ...


TSView = TypeVar('TSView', bound=TimeseriesViewProtocol)

TSContainer = TypeVar('TSContainer', bound='TimeseriesContainerProtocol')


class TimeseriesContainerProtocol(TimeseriesViewProtocol[TSSpec], SlimMapping[str, TSView],
                                  ObservationTypeSpecific, Copyable, Protocol[TSSpec, TSView]):
    """
    The base interface for a container object holding all observations of a specific spec.
    Implementations provide generators for filtered views on the observations.
    """

    @property
    @abstractmethod
    def timeseries_spec(self) -> TSSpec:
        """
        The timeseries spec describing the contained observations' features, i.e., columns in `self.df`.

        :rtype: an implementation of `TimeseriesSpecProtocol`
        """
        ...

    @timeseries_spec.setter
    @abstractmethod
    def timeseries_spec(self, value: TSSpec): ...

    @property
    @abstractmethod
    def df(self) -> pd.DataFrame:
        """
        The actual dataframe holding the observation data.
        Its index is managed by the holding Machine Data instance, it should not be manually modified in place.
        """
        ...

    @df.setter
    @abstractmethod
    def df(self, value: pd.DataFrame): ...

    @classmethod
    @abstractmethod
    def of(cls, timeseries_spec: TSSpec, df: pd.DataFrame, *args, **kwargs) -> typing.Self:
        """Create a new instance of the specified spec and observations in the dataframe."""
        ...

    @property
    @abstractmethod
    def time_series_count(self) -> int:
        """
        The number of individually indexable timeseries that views can be created for.
        By default, that is one per occurring object identifier.
        """
        ...

    @abstractmethod
    def view(self, *args: P.args, **kwargs: P.kwargs) -> TSView:
        """
        Generate a timeseries view specified by `args` and `kwargs`.
        Concrete implementations can offer different slicing capabilities.

        :rtype: an implementation of `TimeseriesViewProtocol`
        """
        ...

    @abstractmethod
    def merge(self, other: typing.Self,
              axis: Literal['horizontal', 'vertical'] = 'vertical', copy: bool = True) -> typing.Self:
        """
        Merge the observations in `self` and `other`.
        A new independent instance is returned, and the underlying dataframe is copied if `copy=True`.

        - `horizontal` extends the dataframe columns by the additional features defined in `other`.
        - `vertical` appends the observations of `other`. The timeseries specs must be equivalent.
        """
        ...

    @classmethod
    def lifted_merge(cls, tscs: Mapping[str, TSContainer], o_tscs: Mapping[str, TSContainer],
                     axis: Literal['horizontal', 'vertical'] = 'vertical', copy=True) -> tuple[
        dict[str, TSContainer], bool]:
        """
        Apply the specified merge to corresponding timeseries containers in `tscs` and `o_tscs`.
        Containers with keys in the symmetric difference of keys are included in the resulting dict as is.
        The returned boolean indicates whether the index of any the underlying dataframes may have changed.
        If `copy=True`, the underlying containers are copied, otherwise their internal dataframes will be linked.
        """
        assert axis in {'horizontal', 'vertical'}
        ov = intersection(tscs.keys(), o_tscs.keys())
        s1, s2 = symmetric_difference(tscs.keys(), o_tscs.keys())

        def maybe_copy(tsc: TSContainer) -> TSContainer:
            return copy_func(tsc) if copy else tsc

        res = ({e: maybe_copy(tscs[e]) for e in s1}
               | {e: tscs[e].merge(o_tscs[e], axis=axis, copy=copy) for e in ov}
               | {e: maybe_copy(o_tscs[e]) for e in s2})
        return res, (axis == 'vertical') | (len(s2) > 0)


ETSSpec = TypeVar('ETSSpec', bound=TimeseriesSpecProtocol, covariant=True)
MTSSpec = TypeVar('MTSSpec', bound=TimeseriesSpecProtocol, covariant=True)
ETSView = TypeVar('ETSView', bound=TimeseriesViewProtocol, covariant=True)
MTSView = TypeVar('MTSView', bound=TimeseriesViewProtocol, covariant=True)
ETSC = TypeVar('ETSC', bound=TimeseriesContainerProtocol, covariant=True)
MTSC = TypeVar('MTSC', bound=TimeseriesContainerProtocol, covariant=True)

MachineData = TypeVar('MachineData', bound='MachineDataProtocol', covariant=True)


class MachineDataProtocol(SlimMapping[ObservationSpecIdentifier, ETSC | MTSC], Copyable,
                          Protocol[ETSSpec, ETSView, ETSC, MTSSpec, MTSView, MTSC]):
    """
    The base interface for all Machine Data representation classes.
    Such classes store header information, observation specs and containers.
    They provide convenience methods to access sub objects' features such as generating views on the data.

    :cvar supported extensions: The extensions explicitly supported by an implementing class.
    """
    supported_extensions: ClassVar[frozenset[Extension]]

    @property
    @abstractmethod
    def meta(self) -> Meta:
        """The header metadata."""
        ...

    @property
    @abstractmethod
    def event_series(self) -> Mapping[EventSpecLabel, ETSC]:
        """A mapping of event labels the corresponding event containers."""
        ...

    @property
    @abstractmethod
    def measurement_series(self) -> Mapping[MeasurementSpecLabel, MTSC]:
        """A mapping of measurement labels to the corresponding measurement containers."""
        ...

    @abstractmethod
    def __getitem__(self, item: ObservationSpecIdentifier) -> ETSC | MTSC: ...

    # @deprecated
    @classmethod
    @abstractmethod
    def of(cls, meta: Meta = Meta(), events: Iterable[ETSC] = (), measurements: Iterable[MTSC] = (), *args: P.args,
           **kwargs: P.kwargs) -> typing.Self:
        """Create a new instance holding the specified event/measurement containers and meta information."""
        ...

    @property
    @abstractmethod
    def header(self) -> Header:
        """A complete Machine Data Header of this instance."""
        ...

    @property
    @abstractmethod
    def index_frame(self) -> pd.DataFrame:
        """An internal index over all contained observations."""
        ...

    @property
    @abstractmethod
    def series_containers(self) -> Set[ETSC | MTSC]:
        """The combined set of event as well as measurement containers."""
        ...

    @property
    @abstractmethod
    def observation_count(self) -> int:
        """The number of observations."""
        ...

    @property
    @abstractmethod
    def objects(self) -> Set[str]:
        """The set of object identifiers that occur in the instance."""
        ...

    @property
    @abstractmethod
    def event_specs(self) -> Mapping[EventSpecLabel, ETSSpec]:
        """A mapping of event spec labels to their timeseries spec objects."""
        ...

    @property
    @abstractmethod
    def measurement_specs(self) -> Mapping[MeasurementSpecLabel, MTSSpec]:
        """A mapping of measurement spec labels to their timeseries spec objects."""
        ...

    @abstractmethod
    def get_spec(self, identifier: ObservationSpecIdentifier, *args) -> ETSSpec | MTSSpec:
        """
        Returns the timeseries spec with id `identifier`.

        :param identifier: the id of the selected timeseries spec
        :rtype: an implementation of `TimeseriesSpecProtocol`
        """
        ...

    @abstractmethod
    def get_events(self, label: EventSpecLabel) -> ETSC:
        """
        Returns the event container of spec `label`.

        :param label: label of selected event spec
        :rtype: implementation of `TimeseriesContainerProtocol`
        """
        ...

    @abstractmethod
    def get_measurements(self, label: MeasurementSpecLabel) -> MTSC:
        """
        Returns the measurement container of spec `label`.

        :param label: label of selected measurement spec
        :rtype: implementation of `TimeseriesContainerProtocol`
        """
        ...

    @abstractmethod
    def view_event_series(self, label: EventSpecLabel, *args: P.args, **kwargs: P.kwargs) -> ETSView:
        """
        Generate a sliced view on the events of spec `label`.
        Implementations can have different arguments and thus slicing capabilities.

        :rtype: implementation of TimeseriesViewProtocol
        :param label: event spec label
        :param args: variable attribute values/slice definition
        :param kwargs: variable attribute values/slice definition
        """
        ...

    @abstractmethod
    def view_measurement_series(self, label: MeasurementSpecLabel, *args: P.args, **kwargs: P.kwargs) -> MTSView:
        """
        Generate a sliced view on the measurements of spec `label`.
        Implementations can have different arguments and thus slicing capabilities.

        :rtype: implementation of TimeseriesViewProtocol_
        :param label: measurement spec label
        :param args: variable attribute values/slice definition
        :param kwargs: variable attribute values/slice definition
        """
        ...

    @abstractmethod
    def recalculate_index(self, override_categorical_types=True, sort_by_time=True, **kwargs):
        """Recalculates the internal index over all contained observations and specs. Typically called automatically."""
        ...

    @abstractmethod
    def fit_to_data(self, ignore_index=False):
        """
        Updates immutable objects such as timeseries specs to be in sync with the underlying mutable dataframes.
        Depending on `ignore_index`, propagate changes to this object's index to series containers, or override this
        index to reflect potentially filtered or extended container dataframes.

        :param ignore_index: whether to override this object's internal index or update container indices with this index
        """
        ...

    @abstractmethod
    def create_joined_df(self, event_series_labels: Iterable[EventSpecLabel] | bool = None,
                         measurement_series_labels: Iterable[MeasurementSpecLabel] | bool = None,
                         prefix_columns_to_avoid_collisions=True, copy=False) -> pd.DataFrame:
        """
        Generate a joined dataframe of the `self.index_frame` and the selected event/measurement container
        dataframes which contain the features of their respective spec.

        :param prefix_columns_to_avoid_collisions: whether to rename the joined feature columns with their spec identifier
        :param copy: whether to return a copy or views on the joined dataframes
        """
        ...

    @abstractmethod
    def create_index_view(self, typ: ObservationTypeValue = None, types: Iterable[ObservationTypeValue] = None,
                          obj: str = None, objs: Iterable[str] = None,
                          label: ObservationSpecLabel = None,
                          labels: Iterable[ObservationSpecLabel] = None) -> pd.DataFrame:
        """
        Generate a filtered view on the `self.index_frame`.

        :param typ: one selected observation type
        :param types: alternatively, a selection of observation types
        :param obj: one selected object identifier
        :param objs:  alternatively, a selection of object identifiers
        :param label: one selected observation label
        :param labels:  alternatively, a selection of observation labels
        """
        ...

    @abstractmethod
    def project(self,
                measurement_feature_selection: Mapping[
                    MeasurementSpecLabel, bool | Collection[TimeseriesFeatureLabel]] = None,
                event_feature_selection: Mapping[EventSpecLabel, bool | Collection[TimeseriesFeatureLabel]] = None,
                project_underlying_dfs=False, copy_underlying_dfs=False) -> typing.Self:
        """
        Project this Machine Data instance to a subset of observation features.
        Returns a new instance that can be independent of `self` if `copy_underlying_dfs` is used.

        :param measurement_feature_selection: per measurement spec label, a selection of features to keep (boolean True/False = all/no features)
        :param event_feature_selection: per event spec label, a selection of features to keep (boolean True/False = all/no features)
        :param project_underlying_dfs: whether to project dataframes of the timeseries containers or leave them untouched
        :param copy_underlying_dfs: whether to copy the timeseries containers' dataframes, or use views
        :return: a new projected Machine Data instance of the same type
        """
        ...

    @abstractmethod
    def is_mergeable(self, other: MachineDataProtocol) -> bool:
        """Checks whether `self` and `other` are mergeable Machine Data instances."""
        ...

    @abstractmethod
    def merge(self, other: MachineData,
              axis: Literal['horizontal', 'vertical'] = 'horizontal', copy: bool = True,
              suppress_index_creation=False) -> MachineData:
        """
        Merges `self` and `other` along the given `axis`.

        :param axis: whether to merge "horizontally" or "vertically"
                - `horizontal` extends shared specs and their observations by the additional features defined in `other`.
                - `vertical` appends the observations of `other`. Shared spec identifiers must refer to equivalent specs.
        :param copy: if `copy=True`, internal dataframes are copied and an independent instance is returned
        :param suppress_index_creation: if `True`, the index is only lazily computed in the resulting merged instance
        """
        ...

    @classmethod
    def lifted_merge(cls, machine_datas: Iterable[MachineData], axis: Literal['horizontal', 'vertical'] = 'horizontal',
                     copy: bool = True, suppress_index_creation=False) -> MachineData:
        assert axis in {'horizontal', 'vertical'}
        machine_datas = list(machine_datas)
        if len(machine_datas) > 0:
            current = machine_datas.pop(0)
            last = machine_datas.pop()
            for md in machine_datas:
                current = current.merge(md, axis=axis, copy=False, suppress_index_creation=True)
            return current.merge(last, axis=axis, copy=copy, suppress_index_creation=suppress_index_creation)


    @abstractmethod
    def summary(self) -> str:
        """Generates a brief textual overview of the data contained in this instance."""
        ...
