"""
    ======================================================
    Python bindings for Universal Key Value store library.
    ======================================================
    
    Supports:
    **********
    * Collection-level CRUD operations, like `dict`.
    * Batch operations & ACID transactions.
    * Graph collections, mimicking `networkx`.
    * Tabular views, mimicking `pandas`.
    * Apache Arrow exports for inter-process communication.
    
    """
from __future__ import annotations
import ustore.ucset
import typing
import numpy
_Shape = typing.Tuple[int, ...]

__all__ = [
    "Collection",
    "DataBase",
    "DataFrame",
    "DiGraph",
    "DiGraphDegreeView",
    "DiGraphDegreesStream",
    "DiGraphEdgesIter",
    "DiGraphEdgesRange",
    "DiGraphEdgesStream",
    "DiGraphNodesRange",
    "DiGraphNodesStream",
    "DocsCollection",
    "DocsKVRange",
    "DocsKVStream",
    "Graph",
    "GraphDegreeView",
    "GraphDegreesStream",
    "GraphEdgesIter",
    "GraphEdgesRange",
    "GraphEdgesStream",
    "GraphNodesRange",
    "GraphNodesStream",
    "ItemsRange",
    "ItemsStream",
    "KeysRange",
    "KeysStream",
    "MultiDiGraph",
    "MultiDiGraphDegreeView",
    "MultiDiGraphDegreesStream",
    "MultiDiGraphEdgesIter",
    "MultiDiGraphEdgesRange",
    "MultiDiGraphEdgesStream",
    "MultiDiGraphNodesRange",
    "MultiDiGraphNodesStream",
    "MultiGraph",
    "MultiGraphDegreeView",
    "MultiGraphDegreesStream",
    "MultiGraphEdgesIter",
    "MultiGraphEdgesRange",
    "MultiGraphEdgesStream",
    "MultiGraphNodesRange",
    "MultiGraphNodesStream",
    "Transaction",
    "from_dict",
    "from_records"
]


class Collection():
    def __contains__(self, arg0: object) -> object: ...
    def __delitem__(self, arg0: object) -> None: ...
    def __getitem__(self, arg0: object) -> object: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: object, arg1: object) -> None: ...
    def broadcast(self, arg0: object, arg1: object) -> None: ...
    def clear(self) -> None: ...
    def get(self, arg0: object) -> object: ...
    def get_matrix(self, arg0: object, arg1: int, arg2: str) -> int: ...
    def has_key(self, arg0: object) -> object: ...
    def pop(self, arg0: object) -> None: ...
    def remove(self) -> None: ...
    def sample_keys(self, arg0: int) -> object: ...
    def scan(self, arg0: int, arg1: int) -> numpy.ndarray[numpy.int64]: ...
    def set(self, arg0: object, arg1: object) -> None: ...
    def set_matrix(self, arg0: object, arg1: object) -> int: ...
    def update(self, arg0: object) -> None: ...
    @property
    def digraph(self) -> object:
        """
        :type: object
        """
    @property
    def docs(self) -> unum::ustore::py_collection_gt<unum::ustore::docs_collection_t>:
        """
        :type: unum::ustore::py_collection_gt<unum::ustore::docs_collection_t>
        """
    @property
    def graph(self) -> object:
        """
        :type: object
        """
    @property
    def items(self) -> object:
        """
        :type: object
        """
    @property
    def keys(self) -> object:
        """
        :type: object
        """
    @property
    def media(self) -> int:
        """
        :type: int
        """
    @property
    def multidigraph(self) -> object:
        """
        :type: object
        """
    @property
    def multigraph(self) -> object:
        """
        :type: object
        """
    @property
    def table(self) -> object:
        """
        :type: object
        """
    pass
class DataBase():
    def __contains__(self, collection: str) -> bool: ...
    def __delitem__(self, collection: str) -> None: ...
    def __enter__(self) -> DataBase: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> bool: ...
    def __getitem__(self, collection: str) -> Collection: ...
    def __init__(self, config: str = '', open: bool = True, prefer_arrow: bool = True) -> None: ...
    def clear(self) -> None: ...
    def close(self) -> None: ...
    def collection_names(self) -> typing.List[str]: ...
    @property
    def main(self) -> Collection:
        """
        :type: Collection
        """
    pass
class DataFrame():
    def __getitem__(self, arg0: handle) -> DataFrame: ...
    def __init__(self, db: DataBase, index: str = '') -> None: ...
    def astype(self, arg0: handle) -> DataFrame: ...
    def drop(self, arg0: object) -> None: ...
    def head(self, arg0: int) -> DataFrame: ...
    @typing.overload
    def insert(self, arg0: str, arg1: object) -> None: ...
    @typing.overload
    def insert(self, arg0: object) -> None: ...
    def loc(self, arg0: handle) -> DataFrame: ...
    def merge(self, arg0: DataFrame) -> None: ...
    def rename(self, arg0: object) -> None: ...
    def sample(self, arg0: int) -> DataFrame: ...
    def tail(self, arg0: int) -> DataFrame: ...
    def to_arrow(self) -> object: ...
    def to_csv(self, arg0: str) -> None: ...
    def to_json(self, path: str = '') -> object: ...
    def to_parquet(self, arg0: str) -> None: ...
    def update(self, arg0: object) -> None: ...
    @property
    def empty(self) -> bool:
        """
        :type: bool
        """
    @property
    def shape(self) -> tuple:
        """
        :type: tuple
        """
    @property
    def size(self) -> int:
        """
        :type: int
        """
    pass
class DiGraph():
    def __contains__(self, n: int) -> bool: ...
    def __getitem__(self, n: int) -> object: ...
    def __init__(self, db: DataBase, index: typing.Optional[str] = None, vertices: typing.Optional[str] = None, relations: typing.Optional[str] = None) -> None: ...
    def __iter__(self) -> None: ...
    def __len__(self) -> int: ...
    def add_edge(self, u_of_edge: int, v_of_edge: int, key: typing.Optional[int] = None, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, ebunch_to_add: object) -> None: ...
    @typing.overload
    def add_edges_from(self, us: object, vs: object, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, table: object, source: str, target: str, edge: str) -> None: ...
    def add_node(self, node_for_adding: int, **kwargs) -> None: ...
    def add_nodes_from(self, nodes_for_adding: object, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def clear_edges(self) -> None: ...
    def community_louvain(self) -> object: ...
    def get_edge_attributes(self, name: str) -> object: ...
    def get_edge_data(self, u: int, v: int, default: object = None) -> object: ...
    def get_node_attributes(self, name: str) -> object: ...
    def has_edge(self, u: int, v: int) -> bool: ...
    def has_node(self, n: int) -> bool: ...
    def nbunch_iter(self, arg0: _object) -> numpy.ndarray[numpy.int64]: ...
    def neighbors(self, n: int) -> object: ...
    @typing.overload
    def number_of_edges(self, arg0: int, arg1: int) -> int: ...
    @typing.overload
    def number_of_edges(self) -> int: ...
    def number_of_nodes(self) -> int: ...
    def predecessors(self, n: int) -> object: ...
    def remove_edge(self, u: int, v: int, key: typing.Optional[int] = None) -> None: ...
    @typing.overload
    def remove_edges_from(self, ebunch: object) -> None: ...
    @typing.overload
    def remove_edges_from(self, us: object, vs: object) -> None: ...
    def remove_node(self, n: int) -> None: ...
    def remove_nodes_from(self, nodes: object) -> None: ...
    def set_edge_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def set_node_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def size(self, weight: str = '') -> int: ...
    def successors(self, n: int) -> object: ...
    @property
    def degree(self) -> DiGraphDegreeView:
        """
        :type: DiGraphDegreeView
        """
    @property
    def edges(self) -> DiGraphEdgesRange:
        """
        :type: DiGraphEdgesRange
        """
    @property
    def in_degree(self) -> DiGraphDegreeView:
        """
        :type: DiGraphDegreeView
        """
    @property
    def nodes(self) -> DiGraphNodesRange:
        """
        :type: DiGraphNodesRange
        """
    @property
    def out_degree(self) -> DiGraphDegreeView:
        """
        :type: DiGraphDegreeView
        """
    pass
class DiGraphDegreeView():
    @typing.overload
    def __call__(self, vs: object, weight: str = '') -> object: ...
    @typing.overload
    def __call__(self, weight: str = '') -> DiGraphDegreeView: ...
    def __getitem__(self, arg0: int) -> int: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class DiGraphDegreesStream():
    def __next__(self) -> object: ...
    pass
class DiGraphEdgesIter():
    def __next__(self) -> object: ...
    pass
class DiGraphEdgesRange():
    @typing.overload
    def __call__(self, keys: bool = False, data: bool = False) -> DiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None, keys: bool = False) -> DiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: bool, keys: bool = False) -> DiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: str, default: object = None, keys: bool = False) -> DiGraphEdgesRange: ...
    def __iter__(self) -> object: ...
    pass
class DiGraphEdgesStream():
    def __next__(self) -> object: ...
    pass
class DiGraphNodesRange():
    @typing.overload
    def __call__(self, data: bool = False) -> DiGraphNodesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None) -> DiGraphNodesRange: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class DiGraphNodesStream():
    def __next__(self) -> object: ...
    pass
class DocsCollection():
    def __contains__(self, arg0: object) -> object: ...
    def __delitem__(self, arg0: object) -> None: ...
    def __getitem__(self, arg0: object) -> object: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: object, arg1: object) -> None: ...
    def broadcast(self, arg0: object, arg1: object) -> None: ...
    def clear(self) -> None: ...
    def get(self, arg0: object) -> object: ...
    def has_key(self, arg0: object) -> object: ...
    def merge(self, arg0: object, arg1: object) -> None: ...
    def patch(self, arg0: object, arg1: object) -> None: ...
    def remove(self, arg0: object) -> None: ...
    def scan(self, arg0: int, arg1: int) -> object: ...
    def set(self, arg0: object, arg1: object) -> None: ...
    @property
    def items(self) -> object:
        """
        :type: object
        """
    @property
    def keys(self) -> object:
        """
        :type: object
        """
    pass
class DocsKVRange():
    def __iter__(self) -> DocsKVStream: ...
    def since(self, arg0: int) -> DocsKVRange: ...
    def until(self, arg0: int) -> DocsKVRange: ...
    pass
class DocsKVStream():
    def __next__(self) -> tuple: ...
    pass
class Graph():
    def __contains__(self, n: int) -> bool: ...
    def __getitem__(self, n: int) -> object: ...
    def __init__(self, db: DataBase, index: typing.Optional[str] = None, vertices: typing.Optional[str] = None, relations: typing.Optional[str] = None) -> None: ...
    def __iter__(self) -> None: ...
    def __len__(self) -> int: ...
    def add_edge(self, u_of_edge: int, v_of_edge: int, key: typing.Optional[int] = None, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, ebunch_to_add: object) -> None: ...
    @typing.overload
    def add_edges_from(self, us: object, vs: object, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, table: object, source: str, target: str, edge: str) -> None: ...
    def add_node(self, node_for_adding: int, **kwargs) -> None: ...
    def add_nodes_from(self, nodes_for_adding: object, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def clear_edges(self) -> None: ...
    def community_louvain(self) -> object: ...
    def get_edge_attributes(self, name: str) -> object: ...
    def get_edge_data(self, u: int, v: int, default: object = None) -> object: ...
    def get_node_attributes(self, name: str) -> object: ...
    def has_edge(self, u: int, v: int) -> bool: ...
    def has_node(self, n: int) -> bool: ...
    def nbunch_iter(self, arg0: _object) -> numpy.ndarray[numpy.int64]: ...
    def neighbors(self, n: int) -> object: ...
    @typing.overload
    def number_of_edges(self, arg0: int, arg1: int) -> int: ...
    @typing.overload
    def number_of_edges(self) -> int: ...
    def number_of_nodes(self) -> int: ...
    def predecessors(self, n: int) -> object: ...
    def remove_edge(self, u: int, v: int, key: typing.Optional[int] = None) -> None: ...
    @typing.overload
    def remove_edges_from(self, ebunch: object) -> None: ...
    @typing.overload
    def remove_edges_from(self, us: object, vs: object) -> None: ...
    def remove_node(self, n: int) -> None: ...
    def remove_nodes_from(self, nodes: object) -> None: ...
    def set_edge_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def set_node_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def size(self, weight: str = '') -> int: ...
    def successors(self, n: int) -> object: ...
    @property
    def degree(self) -> GraphDegreeView:
        """
        :type: GraphDegreeView
        """
    @property
    def edges(self) -> GraphEdgesRange:
        """
        :type: GraphEdgesRange
        """
    @property
    def nodes(self) -> GraphNodesRange:
        """
        :type: GraphNodesRange
        """
    pass
class GraphDegreeView():
    @typing.overload
    def __call__(self, vs: object, weight: str = '') -> object: ...
    @typing.overload
    def __call__(self, weight: str = '') -> GraphDegreeView: ...
    def __getitem__(self, arg0: int) -> int: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class GraphDegreesStream():
    def __next__(self) -> object: ...
    pass
class GraphEdgesIter():
    def __next__(self) -> object: ...
    pass
class GraphEdgesRange():
    @typing.overload
    def __call__(self, keys: bool = False, data: bool = False) -> GraphEdgesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None, keys: bool = False) -> GraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: bool, keys: bool = False) -> GraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: str, default: object = None, keys: bool = False) -> GraphEdgesRange: ...
    def __iter__(self) -> object: ...
    pass
class GraphEdgesStream():
    def __next__(self) -> object: ...
    pass
class GraphNodesRange():
    @typing.overload
    def __call__(self, data: bool = False) -> GraphNodesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None) -> GraphNodesRange: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class GraphNodesStream():
    def __next__(self) -> object: ...
    pass
class ItemsRange():
    def __iter__(self) -> ItemsStream: ...
    def since(self, arg0: int) -> ItemsRange: ...
    def until(self, arg0: int) -> ItemsRange: ...
    pass
class ItemsStream():
    def __next__(self) -> tuple: ...
    pass
class KeysRange():
    def __iter__(self) -> KeysStream: ...
    def since(self, arg0: int) -> KeysRange: ...
    def until(self, arg0: int) -> KeysRange: ...
    pass
class KeysStream():
    def __next__(self) -> int: ...
    pass
class MultiDiGraph():
    def __contains__(self, n: int) -> bool: ...
    def __getitem__(self, n: int) -> object: ...
    def __init__(self, db: DataBase, index: typing.Optional[str] = None, vertices: typing.Optional[str] = None, relations: typing.Optional[str] = None) -> None: ...
    def __iter__(self) -> None: ...
    def __len__(self) -> int: ...
    def add_edge(self, u_of_edge: int, v_of_edge: int, key: typing.Optional[int] = None, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, ebunch_to_add: object) -> None: ...
    @typing.overload
    def add_edges_from(self, us: object, vs: object, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, table: object, source: str, target: str, edge: str) -> None: ...
    @typing.overload
    def add_edges_from(self, us: object, vs: object, keys: object = None, **kwargs) -> None: ...
    def add_node(self, node_for_adding: int, **kwargs) -> None: ...
    def add_nodes_from(self, nodes_for_adding: object, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def clear_edges(self) -> None: ...
    def community_louvain(self) -> object: ...
    def get_edge_attributes(self, name: str) -> object: ...
    def get_edge_data(self, u: int, v: int, default: object = None) -> object: ...
    def get_node_attributes(self, name: str) -> object: ...
    @typing.overload
    def has_edge(self, u: int, v: int) -> bool: ...
    @typing.overload
    def has_edge(self, u: int, v: int, key: int) -> bool: ...
    def has_node(self, n: int) -> bool: ...
    def nbunch_iter(self, arg0: _object) -> numpy.ndarray[numpy.int64]: ...
    def neighbors(self, n: int) -> object: ...
    @typing.overload
    def number_of_edges(self, arg0: int, arg1: int) -> int: ...
    @typing.overload
    def number_of_edges(self) -> int: ...
    def number_of_nodes(self) -> int: ...
    def predecessors(self, n: int) -> object: ...
    def remove_edge(self, u: int, v: int, key: typing.Optional[int] = None) -> None: ...
    @typing.overload
    def remove_edges_from(self, ebunch: object) -> None: ...
    @typing.overload
    def remove_edges_from(self, us: object, vs: object) -> None: ...
    @typing.overload
    def remove_edges_from(self, us: object, vs: object, keys: object = None) -> None: ...
    def remove_node(self, n: int) -> None: ...
    def remove_nodes_from(self, nodes: object) -> None: ...
    def set_edge_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def set_node_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def size(self, weight: str = '') -> int: ...
    def successors(self, n: int) -> object: ...
    @property
    def degree(self) -> MultiDiGraphDegreeView:
        """
        :type: MultiDiGraphDegreeView
        """
    @property
    def edges(self) -> MultiDiGraphEdgesRange:
        """
        :type: MultiDiGraphEdgesRange
        """
    @property
    def in_degree(self) -> MultiDiGraphDegreeView:
        """
        :type: MultiDiGraphDegreeView
        """
    @property
    def nodes(self) -> MultiDiGraphNodesRange:
        """
        :type: MultiDiGraphNodesRange
        """
    @property
    def out_degree(self) -> MultiDiGraphDegreeView:
        """
        :type: MultiDiGraphDegreeView
        """
    pass
class MultiDiGraphDegreeView():
    @typing.overload
    def __call__(self, vs: object, weight: str = '') -> object: ...
    @typing.overload
    def __call__(self, weight: str = '') -> MultiDiGraphDegreeView: ...
    def __getitem__(self, arg0: int) -> int: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class MultiDiGraphDegreesStream():
    def __next__(self) -> object: ...
    pass
class MultiDiGraphEdgesIter():
    def __next__(self) -> object: ...
    pass
class MultiDiGraphEdgesRange():
    @typing.overload
    def __call__(self, keys: bool = False, data: bool = False) -> MultiDiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None, keys: bool = False) -> MultiDiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: bool, keys: bool = False) -> MultiDiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: str, default: object = None, keys: bool = False) -> MultiDiGraphEdgesRange: ...
    def __iter__(self) -> object: ...
    pass
class MultiDiGraphEdgesStream():
    def __next__(self) -> object: ...
    pass
class MultiDiGraphNodesRange():
    @typing.overload
    def __call__(self, data: bool = False) -> MultiDiGraphNodesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None) -> MultiDiGraphNodesRange: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class MultiDiGraphNodesStream():
    def __next__(self) -> object: ...
    pass
class MultiGraph():
    def __contains__(self, n: int) -> bool: ...
    def __getitem__(self, n: int) -> object: ...
    def __init__(self, db: DataBase, index: typing.Optional[str] = None, vertices: typing.Optional[str] = None, relations: typing.Optional[str] = None) -> None: ...
    def __iter__(self) -> None: ...
    def __len__(self) -> int: ...
    def add_edge(self, u_of_edge: int, v_of_edge: int, key: typing.Optional[int] = None, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, ebunch_to_add: object) -> None: ...
    @typing.overload
    def add_edges_from(self, us: object, vs: object, **kwargs) -> None: ...
    @typing.overload
    def add_edges_from(self, table: object, source: str, target: str, edge: str) -> None: ...
    @typing.overload
    def add_edges_from(self, us: object, vs: object, keys: object = None, **kwargs) -> None: ...
    def add_node(self, node_for_adding: int, **kwargs) -> None: ...
    def add_nodes_from(self, nodes_for_adding: object, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def clear_edges(self) -> None: ...
    def community_louvain(self) -> object: ...
    def get_edge_attributes(self, name: str) -> object: ...
    def get_edge_data(self, u: int, v: int, default: object = None) -> object: ...
    def get_node_attributes(self, name: str) -> object: ...
    @typing.overload
    def has_edge(self, u: int, v: int) -> bool: ...
    @typing.overload
    def has_edge(self, u: int, v: int, key: int) -> bool: ...
    def has_node(self, n: int) -> bool: ...
    def nbunch_iter(self, arg0: _object) -> numpy.ndarray[numpy.int64]: ...
    def neighbors(self, n: int) -> object: ...
    @typing.overload
    def number_of_edges(self, arg0: int, arg1: int) -> int: ...
    @typing.overload
    def number_of_edges(self) -> int: ...
    def number_of_nodes(self) -> int: ...
    def predecessors(self, n: int) -> object: ...
    def remove_edge(self, u: int, v: int, key: typing.Optional[int] = None) -> None: ...
    @typing.overload
    def remove_edges_from(self, ebunch: object) -> None: ...
    @typing.overload
    def remove_edges_from(self, us: object, vs: object) -> None: ...
    @typing.overload
    def remove_edges_from(self, us: object, vs: object, keys: object = None) -> None: ...
    def remove_node(self, n: int) -> None: ...
    def remove_nodes_from(self, nodes: object) -> None: ...
    def set_edge_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def set_node_attributes(self, values: object, name: typing.Optional[str] = None) -> None: ...
    def size(self, weight: str = '') -> int: ...
    def successors(self, n: int) -> object: ...
    @property
    def degree(self) -> MultiGraphDegreeView:
        """
        :type: MultiGraphDegreeView
        """
    @property
    def edges(self) -> MultiGraphEdgesRange:
        """
        :type: MultiGraphEdgesRange
        """
    @property
    def nodes(self) -> MultiGraphNodesRange:
        """
        :type: MultiGraphNodesRange
        """
    pass
class MultiGraphDegreeView():
    @typing.overload
    def __call__(self, vs: object, weight: str = '') -> object: ...
    @typing.overload
    def __call__(self, weight: str = '') -> MultiGraphDegreeView: ...
    def __getitem__(self, arg0: int) -> int: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class MultiGraphDegreesStream():
    def __next__(self) -> object: ...
    pass
class MultiGraphEdgesIter():
    def __next__(self) -> object: ...
    pass
class MultiGraphEdgesRange():
    @typing.overload
    def __call__(self, keys: bool = False, data: bool = False) -> MultiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None, keys: bool = False) -> MultiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: bool, keys: bool = False) -> MultiGraphEdgesRange: ...
    @typing.overload
    def __call__(self, vs: object, data: str, default: object = None, keys: bool = False) -> MultiGraphEdgesRange: ...
    def __iter__(self) -> object: ...
    pass
class MultiGraphEdgesStream():
    def __next__(self) -> object: ...
    pass
class MultiGraphNodesRange():
    @typing.overload
    def __call__(self, data: bool = False) -> MultiGraphNodesRange: ...
    @typing.overload
    def __call__(self, data: str, default: object = None) -> MultiGraphNodesRange: ...
    @staticmethod
    def __iter__(*args, **kwargs) -> typing.Any: ...
    pass
class MultiGraphNodesStream():
    def __next__(self) -> object: ...
    pass
class Transaction():
    def __enter__(self) -> Transaction: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> bool: ...
    def __getitem__(self, collection: str) -> Collection: ...
    def __init__(self, db: DataBase, begin: bool = True, watch: bool = True, flush_writes: bool = False, snapshot: bool = False) -> None: ...
    def commit(self) -> None: ...
    @property
    def main(self) -> Collection:
        """
        :type: Collection
        """
    pass
def from_dict(arg0: Collection, arg1: object) -> DataFrame:
    pass
def from_records(arg0: Collection, arg1: object) -> DataFrame:
    pass
