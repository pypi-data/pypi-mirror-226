import logging
import typing
from . import Field as Field, GetResult as GetResult, PropertyValue as PropertyValue
from .Item import Item as Item
from .Slice import Slice as Slice
from .msg import msg as msg
from collections import deque as deque
from itertools import dropwhile as dropwhile, islice as islice
from typing import Any, Dict, Optional, Union

console = logging

class List:
    def __init__(self, localdb: dict, of_item: Item, relation: str, internal: bool = ...) -> None: ...
    @property
    def of_type(self) -> Item: ...
    @property
    def of_item(self) -> Item: ...
    def __len__(self) -> int: ...
    def on_update(self, f: Any) -> None: ...
    def append(self, item: typing.List[Item] | Item | List) -> None: ...
    def create(self, set_value: Optional[typing.List[str | Dict[str, PropertyValue]] | str | Dict[str, PropertyValue]] = ..., set_propname: Optional[str] = ...) -> Optional[Item | list]: ...
    def first(self) -> Optional[Item]: ...
    def before(self, item: Item) -> Item: ...
    def after(self, item: Item) -> Optional[Item]: ...
    def last(self) -> Optional[Item]: ...
    def find(self, searchstring: str) -> Optional[Item]: ...
    def __getitem__(self, search_term: str) -> Optional['Item']: ...
    class __rnIterator:
        index: int
        def __init__(self, r_n_o: List) -> None: ...
        def __next__(self) -> Item: ...
    def recall(self) -> List: ...
    def __iter__(self) -> __rnIterator: ...
    def slice(self, start_at: Optional['Item'] = ..., size: int = ..., search_term: Optional[Any] = ..., search_field: Optional[str] = ...) -> Optional[Slice]: ...
    def define_property(self, name: str, proptype: Union[str, None] = ...) -> Item: ...
    def define_calculated_property(self, name: str, datatype: str, formula: str) -> Item: ...
    def define_link(self, name: str, range: Optional[str] = ..., inverse_name: Optional[str] = ..., inverse_cardinal: Optional[str] = ..., inverse_range: Optional[str] = ...) -> Item: ...
    def define_calculated_link(self, name: str, range: str, formula: str, inverse_name: Optional[str] = ...) -> Item: ...
    def define_list_of_items(self, name: str, inverse_name: Optional[str] = ...) -> Item: ...
    def define_calculated_list(self, name: str, range: str, formula: str, inverse_name: Optional[str] = ...) -> Item: ...
